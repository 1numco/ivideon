Клиент
Консольное приложение. Пользователь вводит команды в бесконечном цикле до введения команды “exit”. Строка с командой передается в фабрику, которая формирует из строки объект команды. Используется паттерн фабрика и команда. Метод execute запускает цепочку синхронной связи с сервером, создает коннект, отправляет строку команды по сети и после получения ответа закрывает соединение.
Добавление новой команды осуществляется путем создания потомка класса ICommand и добавления условия в фабрику.
Логика существующих команд изменяется посредством изменения метода execute в родительском классе, либо переопределения этого метода в классах конкретных команд.
Визуализация работы клиента – вывод на консоль ответов сервера.

Сервер
Чтобы абстрагировать работу сервера и диод, для более простого внесения изменений и тестирования, было принято решение для изменения состояния диода использовать паттерн MVP. Моделью является диод, вью – класс-интерфейс для общения внешнего мира с диодом. Presenter – класс, который слаживает работу вью и модели и абстрагирует диод от внешнего мира. Presenter может использовать разные виды view, чтобы в случае потребности подменить на другой класс-наследник IView с другим функционалом.
В отношениях view и presenter используется паттерн «наблюдатель». View уведомляет presenter’а о появлении новой команды с помощью вызова его метода обработки команд.
Presenter принимает текстовые команды, с помощью фабрики превращает их в объекты команд, исполняет команды и отсылает view результат в виде output аргумента метода status.
Презентер содержит шареные указатели на вью и модель. Каждая команда принимает в качестве аргумента конструктора умный указатель на модель, чтобы иметь возможность модифицировать ее.
 Асинхронный сервер на boost::asio. Сервер содержит умный указатель на вью. Как только приходит запрос от клиента, вызывается метод view, которому передается принятая строка и статус в качестве выходного параметра. Этот статус отдается обратно клиенту. 
Модификация модели – критическая секция, поэтому защитим ее мьютексом.
Добавление новой команды осуществляется путем создания потомка класса ICommand и добавления условия в фабрику.
Логика существующих команд изменяется посредством изменения метода execute в родительском классе, либо переопределения этого метода в классах конкретных команд.
Обработка нескольких клиентов в реальном времени достигается за счет использования асинхронных(неблокирующих) функций библиотеки boost::asio.
Сервер обрабатывает ошибки с помощью error_codes в callback’ах асинхронных функций, в части изменения состояния диода ошибки обрабатываются с помощью отлова исключений и передачи статуса успешности проведения изменения серверу.
Визуализация работы заключается в выводе на экран измененного состояния диода после каждого успешного запроса.
